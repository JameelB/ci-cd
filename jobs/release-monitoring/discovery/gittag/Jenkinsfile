#!groovy

//Helper methods, should eventually be moved tio a shared library

//remote repository checkout
def checkoutGitRepo(gitUrl, gitRef, credentialsID) {
    checkout([$class: 'GitSCM', branches: [[name: gitRef]],
            doGenerateSubmoduleConfigurations: false,
            extensions: [],
            submoduleCfg: [],
            userRemoteConfigs: [[credentialsId: credentialsID, url: gitUrl]]])
}

def getLabelScore(label) {    
    if (!label) {
        return 0
    }

    def score = 0
    def scores = [
            'GA': 1,
            'redhat': 1
    ]
    def parts = label.tokenize('-')

    parts.each { part ->
        if (scores.containsKey(part)) {
            score += scores[part]
        }

        if (!scores.containsKey(part) && part.isInteger()) {
            score += part.toInteger()
        }
    }

    return score
}

//Fetch data from git with credentials
def gitFetch(url, gitTokenId) {
  def response = null
  def data = null

  withCredentials([string(credentialsId: gitTokenId, variable: 'gitToken')]) {
    def headers = [
            ["name": "Authorization", "value": "token ${env.gitToken}"]
    ]

    response = httpRequest customHeaders: headers, url: url
    data = readJSON text: response.content
  }

  return [response.status, data]
}

//Gets the latest release by git tags
def getLatestReleaseByTag(gitOrg, gitRepo, gitTokenId, productName) {
  def latestRelease = ""
  def url = "https://api.github.com/repos/${gitOrg}/${gitRepo}/git/refs/tags"

  def (code, releases) = gitFetch(url, gitTokenId)
  if (code != 200) {
    error "[ERROR] Failed to retrieve tags for:${productName}. The :${gitRepo} repository does not have any tags available"
  }

  if (productName == "fuse") {
    releases = releases.findAll{release -> release.ref.contains("-redhat-")}
  }

  latestRelease = releases.get(releases.size() - 1).ref
  latestRelease = latestRelease.minus("refs/tags/")


  return latestRelease
}

//Gets the latest release by git releases
def getLatestReleaseByRelease(gitOrg, gitRepo, gitTokenId, productName) {
  def url = "https://api.github.com/repos/${gitOrg}/${gitRepo}/releases/latest"

  def (code, release) = gitFetch(url, gitTokenId)
  if (code != 200) {
    error "[ERROR] Failed to retrieve latest release for:${productName}. The :${gitRepo} repository does not have any releases available"
  }

  return release.tag_name
}

//Gets the latest release of a product from the project repository
def getLatestRelease(gitOrg, gitRepo, gitTokenId, productName) {
    println "[INFO] Getting latest release for:${productName}"

    if (productName == "fuse" || productName == "fuse-online") {
      return getLatestReleaseByTag(gitOrg, gitRepo, gitTokenId, productName)
    } else {
      return getLatestReleaseByRelease(gitOrg, gitRepo, gitTokenId, productName)
    }
}

//checks if current semver is lower than the supposed latest one
def hasNewGARelease(currentVersion, newVersion) {
    def current = currentVersion.replaceAll("[^0-9]", "").tokenize('.')
    def latest = newVersion.replaceAll("[^0-9]", "").tokenize('.')
    
    println "[INFO] current:${current}, latest:${latest}"

    def currentMajor = current[0] as Integer
    def latestMajor = latest[0] as Integer
    def currentMinor = current[1] as Integer
    def latestMinor = latest[1] as Integer
    def currentPatch = current[2] as Integer
    def latestPatch = latest[2] as Integer
    def currentLabel = current[3]
    def latestLabel = latest[3]

    def previousVer = 0
    def currentVer = 0
    for (i = 0; i <= 2; i++) {
        if (i > 0) {
            previousVer = i - 1
        }
        currentVer = i

        def previousDiff = current[previousVer] == latest[previousVer]
        if (i == 0) {
            previousDiff = true
        }
        def currentDiff = latest[currentVer] > current[currentVer]
        if (previousDiff && currentDiff) {
            return true
        }
    }

    def currentLabelScore = getLabelScore(currentLabel)
    def latestLabelScore = getLabelScore(latestLabel)

    if (latestLabelScore > currentLabelScore) {
        return true
    }

    return false
}

//Helper methods

def installationGitUrl = params.installationGitUrl ?: 'git@github.com:integr8ly/installation.git'
def installationGitRef = params.installationGitRef ?: 'master'
def githubToken = params.githubToken ?: 'jenkins-github-api-token'
def githubCredentialsID = params.credentialId ?: 'jenkinsgithub'
def manifestVar = params.manifestVar
def projectOrg = params.projectOrg
def projectRepo = params.projectRepo
def productName = params.productName
def nextBranch = params.installationProductBranch ?: "${productName}-next"
def installationManifestFile = './evals/inventories/group_vars/all/manifest.yaml'

currentBuild.displayName = "${currentBuild.displayName} ${productName}"

node {
    cleanWs()
    stage('Fetch Installation Repo') {
        println '[INFO] Fetch Installation Repo'
        cleanWs()
        dir('installation') {
            checkoutGitRepo(installationGitUrl, installationGitRef, githubCredentialsID)
            releaseConfig = readYaml file: installationManifestFile
            componentRelease = releaseConfig[manifestVar]
        }
    }

    stage('Fetch Latest Release') {
        latestRelease = getLatestRelease(projectOrg, projectRepo, githubToken, productName)

        if (latestRelease == "" || componentRelease == "") {
            error "[ERROR] Error while retrieving releases: ${latestRelease}:${componentRelease}"
        }

        println "[INFO] latestRelease:${latestRelease}, componentRelease:${componentRelease}"

        // TODO: Implement changes in hasNewGARelease that can compare the 2 versions correctly
        isGARelease = hasNewGARelease(componentRelease, latestRelease)
        println "[INFO] latestRelease:${latestRelease}, componentRelease:${componentRelease}, isGARelease:${isGARelease}"
        currentBuild.description = "latest: ${latestRelease}\ncurrent: ${componentRelease}"
    }
}
